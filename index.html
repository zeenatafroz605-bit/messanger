<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MiniChat — P2P (no server required)</title>
  <style>
    :root{--bg:#f6f7fb;--card:#fff;--accent:#0b84ff}
    body{font-family:Inter, system-ui, Arial; background:var(--bg); margin:0;padding:20px}
    .app{max-width:900px;margin:0 auto}
    .row{display:flex;gap:12px}
    .col{flex:1}
    .card{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 6px 18px rgba(9,10,20,0.06)}
    h1{font-size:18px;margin:0 0 8px}
    textarea{width:100%;height:120px;padding:8px;border-radius:8px;border:1px solid #e6e9ef}
    input[type=text]{width:100%;padding:8px;border-radius:8px;border:1px solid #e6e9ef}
    button{background:var(--accent);color:white;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
    .log{height:380px;overflow:auto;padding:10px;border-radius:8px;background:#fbfcff;border:1px dashed #e6e9ef}
    .msg{margin-bottom:8px;padding:8px;border-radius:8px;display:inline-block}
    .out{background:#e6f0ff}
    .in{background:#f1f3f5}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .small{font-size:12px;color:#666}
    .file-list{margin-top:8px}
    .status{margin-top:8px;font-weight:600}
    footer{margin-top:12px;font-size:12px;color:#666}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>MiniChat — WhatsApp-like web (P2P, no install)</h1>
      <div class="small">This page creates a direct peer-to-peer connection using WebRTC. No server needed — share the SDP text between devices (copy-paste) or use a simple signaling page.</div>
      <div style="height:12px"></div>
      <div class="row">
        <div class="col card">
          <div><strong>Create / Host (A)</strong></div>
          <div style="height:6px"></div>
          <div class="controls">
            <button id="createOffer">Create Offer (A → B)</button>
            <button id="createAnswer" disabled>Create Answer (B → A)</button>
            <button id="closeConn" disabled>Close</button>
          </div>
          <div class="status" id="connStatus">Not connected</div>
          <div style="height:8px"></div>
          <label>Local SDP (share with remote):</label>
          <textarea id="localSDP" readonly placeholder="Local SDP will appear here"></textarea>
        </div>
        <div class="col card">
          <div><strong>Join / Remote (B)</strong></div>
          <div style="height:6px"></div>
          <label>Paste remote SDP here:</label>
          <textarea id="remoteSDP" placeholder="Paste offer/answer from other device"></textarea>
          <div style="height:8px" ></div>
          <div class="controls">
            <button id="acceptRemote">Accept Remote SDP</button>
            <button id="importAnswer" disabled>Import Answer</button>
          </div>
        </div>
      </div>

      <div style="height:12px"></div>
      <div class="row">
        <div class="col card">
          <div><strong>Chat</strong></div>
          <div class="log" id="log"></div>
          <div style="height:8px"></div>
          <div style="display:flex;gap:8px">
            <input id="msgInput" type="text" placeholder="Type a message..." />
            <button id="sendBtn" disabled>Send</button>
            <input id="fileInput" type="file" style="display:none" />
            <button id="sendFileBtn" disabled>Send File</button>
          </div>
          <div class="file-list" id="files"></div>
        </div>
        <div class="col card">
          <div><strong>Hints & Tips</strong></div>
          <ol>
            <li>Open this page on two devices (phone & laptop).</li>
            <li>On A: click "Create Offer" → copy the Local SDP text and send to B (via SMS/email).</li>
            <li>On B: paste that SDP into "Remote SDP" and click "Accept Remote SDP" — B will generate an answer; copy that answer back to A and paste into A's "Remote SDP" then click "Accept Remote SDP" or click "Import Answer" on A.</li>
            <li>Once connected you can send messages and files directly (P2P).</li>
          </ol>
          <div style="height:8px"></div>
          <div class="small">Works across networks when both peers have public IPs or when NAT traversal (ICE) succeeds. For easier setup you can host a tiny signaling server later, but it's not required for copy/paste SDP method.</div>
        </div>
      </div>
      <footer>Made for you — open-source, single HTML file. Save as <code>minichat.html</code> and open in browser.</footer>
    </div>
  </div>

<script>
let pc = null;
let dc = null;
let logEl = document.getElementById('log');
let localSDP = document.getElementById('localSDP');
let remoteSDP = document.getElementById('remoteSDP');
let connStatus = document.getElementById('connStatus');
let sendBtn = document.getElementById('sendBtn');
let msgInput = document.getElementById('msgInput');
let createOfferBtn = document.getElementById('createOffer');
let createAnswerBtn = document.getElementById('createAnswer');
let acceptRemoteBtn = document.getElementById('acceptRemote');
let importAnswerBtn = document.getElementById('importAnswer');
let closeConnBtn = document.getElementById('closeConn');
let sendFileBtn = document.getElementById('sendFileBtn');
let fileInput = document.getElementById('fileInput');
let filesDiv = document.getElementById('files');

function log(msg, dir){
  let d = document.createElement('div'); d.className = 'msg ' + (dir||'in'); d.textContent = msg; logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight;
}

function setStatus(s){ connStatus.textContent = s; }

function makePeer(){
  pc = new RTCPeerConnection({iceServers:[{urls:['stun:stun.l.google.com:19302']} ]});
  pc.onicecandidate = e => {
    if(e.candidate===null) localSDP.value = JSON.stringify(pc.localDescription);
  };
  pc.onconnectionstatechange = ()=>{
    setStatus(pc.connectionState);
  };
  pc.ondatachannel = e => {
    setupDC(e.channel);
  };
}

function setupDC(channel){
  dc = channel;
  dc.onopen = ()=>{ setStatus('connected'); sendBtn.disabled = false; sendFileBtn.disabled=false; closeConnBtn.disabled=false; }
  dc.onmessage = async (e) =>{
    // handle file chunks or text
    try{
      let obj = JSON.parse(e.data);
      if(obj.type==='file-meta'){
        let meta = obj.meta;
        filesDiv.innerHTML += `<div class="small">Incoming file: ${meta.name} (${Math.round(meta.size/1024)} KB) — waiting for chunks...</div>`;
      } else if(obj.type==='text'){
        log(obj.text,'in');
      }
    }catch(err){
      // not JSON -> assume raw text
      log(e.data,'in');
    }
  };
}

createOfferBtn.onclick = async ()=>{
  makePeer();
  let channel = pc.createDataChannel('chat');
  setupDC(channel);
  let offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // wait for ICE to gather -> onicecandidate will set localSDP when done
  createOfferBtn.disabled = true;
  createAnswerBtn.disabled = true;
  setStatus('creating offer — wait for local SDP to appear');
};

acceptRemoteBtn.onclick = async ()=>{
  try{
    let obj = JSON.parse(remoteSDP.value);
    if(!pc){ makePeer(); }
    await pc.setRemoteDescription(obj);
    if(obj.type === 'offer'){
      // we're the callee: create answer
      let answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      // localSDP will populate after ICE
      setStatus('created answer — copy Local SDP and send back');
      importAnswerBtn.disabled = false;
    } else if(obj.type === 'answer'){
      setStatus('remote answer applied');
    }
  }catch(e){ alert('Invalid SDP JSON. Paste exactly what the other side shared.'); }
};

importAnswerBtn.onclick = async ()=>{
  try{
    let obj = JSON.parse(remoteSDP.value);
    if(pc && obj.type==='answer'){
      await pc.setRemoteDescription(obj);
      setStatus('connected (if ICE succeeded)');
      importAnswerBtn.disabled = true;
    } else alert('Paste an answer JSON here.');
  }catch(e){ alert('Invalid JSON'); }
};

sendBtn.onclick = ()=>{
  let t = msgInput.value.trim(); if(!t||!dc||dc.readyState!=='open') return;
  dc.send(JSON.stringify({type:'text', text:t}));
  log(t,'out'); msgInput.value='';
};

sendFileBtn.onclick = ()=> fileInput.click();
fileInput.onchange = async ()=>{
  let f = fileInput.files[0]; if(!f||!dc||dc.readyState!=='open') return;
  // send metadata first
  dc.send(JSON.stringify({type:'file-meta', meta:{name:f.name, size:f.size, mime:f.type}}));
  // send file as ArrayBuffer in chunks
  const chunkSize = 16*1024;
  let offset=0;
  let reader = new FileReader();
  reader.onload = e=>{
    dc.send(e.target.result);
    offset += e.target.result.byteLength;
    if(offset < f.size){
      readSlice(offset);
    } else {
      dc.send(JSON.stringify({type:'file-end'}));
    }
  };
  function readSlice(o){
    const slice = f.slice(o, o+chunkSize);
    reader.readAsArrayBuffer(slice);
  }
  readSlice(0);
  filesDiv.innerHTML += `<div class="small">Sent file: ${f.name} (${Math.round(f.size/1024)} KB)</div>`;
};

closeConnBtn.onclick = ()=>{
  if(dc) dc.close(); if(pc) pc.close(); dc=null; pc=null; setStatus('closed'); sendBtn.disabled=true; sendFileBtn.disabled=true; closeConnBtn.disabled=true; createOfferBtn.disabled=false; importAnswerBtn.disabled=true; }

// Small helper: accept pasted answer into local when host pastes remote answer and clicks Accept
// Also support receiving ArrayBuffer data (file transfer). We'll add ondata to pc when channel exists.

// enhance datachannel message handler to accept binary
(function enhance(){
  const originalSetup = setupDC;
  setupDC = function(channel){
    dc = channel;
    dc.binaryType = 'arraybuffer';
    dc.onopen = ()=>{ setStatus('connected'); sendBtn.disabled = false; sendFileBtn.disabled=false; closeConnBtn.disabled=false; };
    let incomingFile = null; let chunks = [];
    dc.onmessage = async (e)=>{
      if(typeof e.data === 'string'){
        try{
          let obj = JSON.parse(e.data);
          if(obj.type==='file-meta'){ incomingFile = {meta: obj.meta, received:0}; filesDiv.innerHTML += `<div class="small">Incoming: ${obj.meta.name} (${Math.round(obj.meta.size/1024)} KB)</div>`; }
          else if(obj.type==='file-end'){ // assemble
            let blob = new Blob(chunks);
            let a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = incomingFile.meta.name; a.textContent = 'Download ' + incomingFile.meta.name; let wrap = document.createElement('div'); wrap.appendChild(a); filesDiv.appendChild(wrap);
            incomingFile = null; chunks=[];
          } else if(obj.type==='text'){
            log(obj.text,'in');
          }
        }catch(err){ log(e.data,'in'); }
      } else if(e.data instanceof ArrayBuffer){
        chunks.push(new Uint8Array(e.data));
      }
    };
  };
})();

</script>
</body>
</html>
